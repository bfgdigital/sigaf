<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Bitcoin "Should I Give a Fuck" Meter</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <style>
            * {
                box-sizing: border-box;
            }

            body {
                font-family:
                    -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui,
                    sans-serif;
                background: #fafafa;
                color: #1a1a1a;
                margin: 0;
                padding: 20px;
                line-height: 1.4;
                min-height: 100vh;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .container {
                max-width: 900px;
                width: 100%;
                margin: 0 auto;
                background: white;
                border-radius: 12px;
                box-shadow: 0 2px 20px rgba(0, 0, 0, 0.08);
                overflow: hidden;
            }

            .header {
                text-align: center;
                padding: 40px 30px 30px;
                background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
                border-bottom: 1px solid #e9ecef;
            }

            .main-title {
                font-size: 2.2em;
                font-weight: 700;
                margin: 0;
                color: #1a1a1a;
            }

            .weekly-movement {
                font-size: 1em;
                margin: 12px 0 0 0;
                opacity: 0.7;
            }

            .velocity-up {
                color: #059669;
            }

            .velocity-down {
                color: #dc2626;
            }

            .block-info {
                font-size: 0.85em;
                color: #6b7280;
                margin-top: 16px;
                padding-top: 16px;
                border-top: 1px solid #e5e7eb;
            }

            .content {
                padding: 30px;
            }

            .section {
                margin-bottom: 32px;
            }

            .section-title {
                font-size: 1.1em;
                font-weight: 600;
                color: #374151;
                margin-bottom: 16px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                font-size: 0.9em;
            }

            .macro-table {
                width: 100%;
                border-collapse: collapse;
                background: #f8f9fa;
                border-radius: 8px;
                overflow: hidden;
            }

            .macro-table td {
                padding: 16px 12px;
                text-align: center;
                border-right: 1px solid #e9ecef;
            }

            .macro-table td:last-child {
                border-right: none;
            }

            .macro-table .label {
                font-size: 0.8em;
                color: #6b7280;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                display: block;
                margin-bottom: 4px;
            }

            .macro-table .value {
                font-size: 1em;
                font-weight: 600;
                color: #1a1a1a;
                position: relative;
            }

            .tooltip {
                position: fixed;
                background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
                color: #1a1a1a;
                padding: 16px 20px;
                border-radius: 8px;
                font-size: 0.9em;
                width: 300px;
                line-height: 1.5;
                z-index: 9999;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
                opacity: 0;
                visibility: hidden;
                transition:
                    opacity 0.2s,
                    visibility 0.2s;
                border: 1px solid #e9ecef;
                pointer-events: none;
            }

            .tooltip::before {
                content: "";
                position: absolute;
                top: -6px;
                right: 20px;
                width: 12px;
                height: 12px;
                background: #ffffff;
                border-left: 1px solid #e9ecef;
                border-top: 1px solid #e9ecef;
                transform: rotate(45deg);
            }

            .value:hover .tooltip {
                opacity: 1;
                visibility: visible;
            }

            .tooltip-icon {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                width: 16px;
                height: 16px;
                background: #e5e7eb;
                color: #6b7280;
                border-radius: 50%;
                font-size: 11px;
                margin-left: 4px;
                cursor: help;
                font-weight: 600;
                vertical-align: middle;
            }

            .tooltip-icon-subtle {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                width: 14px;
                height: 14px;
                background: #f3f4f6;
                color: #9ca3af;
                border-radius: 50%;
                font-size: 10px;
                margin-left: 3px;
                cursor: help;
                font-weight: 600;
                vertical-align: middle;
                opacity: 0.6;
            }

            .value {
                display: inline-flex;
                align-items: center;
                position: relative;
            }

            .micro-grid {
                display: grid;
                grid-template-columns: repeat(5, 1fr);
                gap: 12px;
            }

            .micro-card {
                background: #f8f9fa;
                border-radius: 8px;
                padding: 16px 12px;
                text-align: center;
                transition: all 0.2s ease;
            }

            .micro-card:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            }

            .micro-card .horizon {
                font-size: 0.75em;
                color: #6b7280;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.3px;
            }

            .micro-card .signal {
                font-size: 1.4em;
                font-weight: 700;
                margin: 8px 0;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }

            .micro-card .detail {
                font-size: 0.8em;
                color: #6b7280;
                margin-top: 8px;
            }

            .sig-meh {
                color: #6b7280;
            }

            .sig-watch {
                color: #2563eb;
            }

            .sig-no-bueno {
                color: #dc2626;
            }

            .sig-party {
                color: #059669;
            }

            .sig-peachy {
                color: #d97706;
            }

            .final-word {
                background: linear-gradient(135deg, #1a1a1a 0%, #374151 100%);
                color: white;
                text-align: center;
                padding: 50px 30px;
                margin: 0;
            }

            .final-question {
                font-size: 1.3em;
                font-weight: 400;
                margin-bottom: 20px;
                opacity: 0.8;
            }

            .final-answer {
                font-size: 4em;
                font-weight: 800;
                margin: 0;
                text-transform: lowercase;
                letter-spacing: -2px;
            }

            .verdict-yep {
                color: #10b981;
            }

            .verdict-no {
                color: #ef4444;
            }

            .verdict-yeah-nah {
                color: #f59e0b;
            }

            .footer {
                padding: 30px;
                text-align: center;
                background: #f8f9fa;
                border-top: 1px solid #e9ecef;
            }

            .footer-text {
                font-size: 0.9em;
                color: #6b7280;
                margin-bottom: 16px;
            }

            .footer-link {
                font-size: 0.85em;
                color: #2563eb;
                text-decoration: none;
            }

            .footer-link:hover {
                text-decoration: underline;
            }

            .error {
                background: #fef2f2;
                color: #dc2626;
                padding: 20px;
                margin: 20px;
                border-radius: 8px;
                border: 1px solid #fecaca;
                text-align: center;
            }

            .calculating-overlay {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(255, 255, 255, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 1.2em;
                color: #374151;
                z-index: 10;
                backdrop-filter: blur(4px);
            }

            @media (max-width: 640px) {
                body {
                    padding: 10px;
                }

                .header {
                    padding: 30px 20px 20px;
                }

                .content,
                .footer {
                    padding: 20px;
                }

                .main-title {
                    font-size: 1.8em;
                }

                .final-answer {
                    font-size: 3em;
                }

                .micro-grid {
                    grid-template-columns: repeat(2, 1fr);
                }
            }
        </style>
    </head>

    <body>
        <div class="container">
            <div class="header">
                <div class="weekly-movement" id="weeklyMovement"></div>
                <h1 class="main-title" id="mainTitle">Should I Give A Fuck?</h1>
                <div
                    class="block-info"
                    id="blockInfo"
                    style="display: none"
                ></div>
            </div>

            <div class="content">
                <div class="section">
                    <div class="section-title">Geometric Benchmark</div>
                    <table class="macro-table">
                        <tr>
                            <td>
                                <span class="label">Current Trend Angle</span>
                                <span class="value" id="currentAngle"
                                    >—<span class="tooltip-icon">?</span>
                                    <div class="tooltip">
                                        This is our dynamic benchmark. It's the
                                        angle of the line from Bitcoin's origin
                                        to its current price, normalized within
                                        a 1x1 box (Time vs Price/ATH). Recent
                                        momentum is compared against this angle.
                                    </div>
                                </span>
                            </td>
                            <td>
                                <span class="label">ATH Benchmark</span>
                                <span class="value" id="benchmarkAngle"
                                    >45°<span class="tooltip-icon">?</span>
                                    <div class="tooltip">
                                        The theoretical ideal. This represents a
                                        perfect, straight line from origin to
                                        the All-Time High price on the
                                        normalized chart. It serves as a fixed
                                        reference point.
                                    </div>
                                </span>
                            </td>
                            <td>
                                <span class="label">Current Price</span>
                                <span class="value" id="macroPrice"
                                    >—<span class="tooltip-icon-subtle">?</span>
                                    <div class="tooltip">
                                        Bitcoin's price at the most recent data
                                        point.
                                    </div>
                                </span>
                            </td>
                            <td>
                                <span class="label">All Time High</span>
                                <span class="value" id="athPrice"
                                    >—<span class="tooltip-icon-subtle">?</span>
                                    <div class="tooltip">
                                        Bitcoin's highest recorded price. This
                                        defines the top of our geometric chart.
                                    </div>
                                </span>
                            </td>
                        </tr>
                    </table>
                </div>

                <div class="section">
                    <div class="section-title">
                        Recent Momentum (Geometrically Derived Lookbacks)
                    </div>
                    <div class="micro-grid" id="microGrid">
                        <div class="calculating-overlay">
                            Calibrating & Analyzing...
                        </div>
                    </div>
                </div>
            </div>

            <div class="final-word">
                <div class="final-question">
                    So, should you give a fuck about the price of Bitcoin?
                </div>
                <div class="final-answer" id="finalWord">...</div>
            </div>

            <div class="footer">
                <div class="footer-text">
                    Each horizon shows the velocity and direction of recent
                    price movement.<br />
                    If the consensus of signals is strongly negative, then you
                    should give a fuck.
                </div>
                <a href="wtfit.html" class="footer-link"
                    >Read the full explanation →</a
                >
                <div class="error" id="errorStatus" style="display: none"></div>
            </div>
        </div>

        <script>
            /******************************************************************
             *
             * CONFIGURATION & DESIGN CHOICES
             * All "tuning knobs" and constants are here for transparency.
             *
             ******************************************************************/
            const CONFIG = {
                // --- Data Source ---
                CSV_URL: "data/btc-price-history-data.csv",
                GENESIS_DATE: new Date("2009-01-03T00:00:00Z"),

                // --- UI & Verdict Thresholds ---
                UI_CONFIG: {
                    finalScoreScale: 15, // Normalizes the final score to this scale for consistent display.
                    positiveThreshold: 8, // Score above this is a "No."
                    negativeThreshold: -8, // Score below this is a "Yep.."
                },

                // --- Geometric Model Parameters ---
                GEO_MODEL_CONFIG: {
                    // We now define the two extreme "personalities" of our lookback generator.
                    // The model will automatically interpolate between these two states based on
                    // the curvature of the macro price trend.

                    // Behavior for a STEEPENING curve (strong momentum).
                    // Creates a wide spread of lookbacks for a broad view.
                    steepeningLookbackConfig: {
                        startCycles: 0.5,
                        endCycles: 250,
                    },

                    // Behavior for a FLATTENING curve (slowing momentum).
                    // Creates a tight cluster of recent lookbacks to focus on the "micro".
                    flatteningLookbackConfig: {
                        startCycles: 10.0,
                        endCycles: 300,
                    },

                    // This controls how sensitive the model is to changes in curvature.
                    // Higher values mean a small change in curvature has a bigger effect.
                    curvatureSensitivity: 10.0,

                    // The number of final lookbacks to generate and display.
                    numFinalLookbacks: 5,
                },
            };

            /******************************************************************
             *
             * HELPER FUNCTIONS
             *
             ******************************************************************/

            function calculateQuadraticFit(data) {
                const n = data.length;
                if (n < 3) return { a: 0, b: 0, c: 0 };

                let sumX = 0,
                    sumY = 0,
                    sumX2 = 0,
                    sumX3 = 0,
                    sumX4 = 0,
                    sumXY = 0,
                    sumX2Y = 0;

                for (const point of data) {
                    const x = point.x;
                    const y = point.y;
                    const x2 = x * x;
                    sumX += x;
                    sumY += y;
                    sumX2 += x2;
                    sumX3 += x * x2;
                    sumX4 += x2 * x2;
                    sumXY += x * y;
                    sumX2Y += x2 * y;
                }

                const S = [
                    [n, sumX, sumX2],
                    [sumX, sumX2, sumX3],
                    [sumX2, sumX3, sumX4],
                ];
                const detS =
                    S[0][0] * (S[1][1] * S[2][2] - S[1][2] * S[2][1]) -
                    S[0][1] * (S[1][0] * S[2][2] - S[1][2] * S[2][0]) +
                    S[0][2] * (S[1][0] * S[2][1] - S[1][1] * S[2][0]);
                if (Math.abs(detS) < 1e-9) return { a: 0, b: 0, c: 0 };

                const Y = [sumY, sumXY, sumX2Y];
                const detA =
                    S[0][0] * (S[1][1] * Y[2] - Y[1] * S[2][1]) -
                    S[0][1] * (S[1][0] * Y[2] - Y[1] * S[2][0]) +
                    Y[0] * (S[1][0] * S[2][1] - S[1][1] * S[2][0]);
                const detB =
                    S[0][0] * (Y[1] * S[2][2] - S[1][2] * Y[2]) -
                    Y[0] * (S[1][0] * S[2][2] - S[1][2] * S[2][0]) +
                    S[0][2] * (S[1][0] * Y[2] - Y[1] * S[2][0]);
                const detC =
                    Y[0] * (S[1][1] * S[2][2] - S[1][2] * S[2][1]) -
                    S[0][1] * (Y[1] * S[2][2] - S[1][2] * Y[2]) +
                    S[0][2] * (Y[1] * S[2][1] - S[1][1] * Y[2]);

                return { a: detA / detS, b: detB / detS, c: detC / detS };
            }

            /**
             * Generates a consistent set of lookbacks that are dynamically adjusted
             * based on the overall market's momentum (curvature).
             * @param {number} latestBlock - The most recent block number.
             * @param {number} curvature - The 'a' coefficient from the quadratic fit.
             * @param {number} trueBlocksPerDay - The calculated average number of blocks per day.
             * @param {Object} config - Configuration object from GEO_MODEL_CONFIG.
             * @returns {Array<number>} An array of lookback periods in blocks.
             */
            function generateConsistentLookbacks(
                latestBlock,
                curvature,
                config,
            ) {
                const {
                    steepeningLookbackConfig,
                    flatteningLookbackConfig,
                    curvatureSensitivity,
                    numFinalLookbacks,
                } = config;

                // 1. Create a bounded "modulation factor" from -1 to 1 using tanh.
                // This gives us a stable way to measure the direction and intensity of the curvature.
                const modulationFactor = Math.tanh(
                    curvature * curvatureSensitivity,
                );

                // 2. Remap the modulation factor to a 0-to-1 scale (alpha).
                // alpha = 0 means fully flattening.
                // alpha = 1 means fully steepening.
                // alpha = 0.5 is neutral.
                const alpha = (modulationFactor + 1) / 2;

                // 3. Linearly interpolate between our two defined states using alpha.
                const lerp = (a, b, t) => a * (1 - t) + b * t;
                const startCycles = lerp(
                    flatteningLookbackConfig.startCycles,
                    steepeningLookbackConfig.startCycles,
                    alpha,
                );
                const endCycles = lerp(
                    flatteningLookbackConfig.endCycles,
                    steepeningLookbackConfig.endCycles,
                    alpha,
                );

                // --- The rest of the function calculates the peaks from this dynamic chirp ---
                const f0 = startCycles;
                const k = endCycles - startCycles;
                const candidates = [];

                const A = k;
                const B = 2 * f0;

                for (let n = 0; ; n++) {
                    const C = -(n + 0.5);
                    const discriminant = B * B - 4 * A * C;
                    if (discriminant < 0) break;

                    const x = (-B + Math.sqrt(discriminant)) / (2 * A);
                    if (x > 1.0) break;

                    if (x > 0) {
                        const peakBlock = x * latestBlock;
                        const lookback = Math.round(latestBlock - peakBlock);
                        if (lookback > 10) candidates.push(lookback);
                    }
                }

                // Return the N most recent (shortest) lookbacks, which will then be sorted for display.
                return candidates
                    .sort((a, b) => a - b)
                    .slice(0, numFinalLookbacks);
            }

            function parseCsvLines(lines, calibratedBlockTimeMs) {
                if (calibratedBlockTimeMs <= 0) return [];
                const genesisTime = CONFIG.GENESIS_DATE.getTime();
                return lines
                    .map((line) => {
                        const cells = line.split(",");
                        let date, price;
                        if (cells[0].includes("-") && cells[0].length === 10)
                            date = new Date(cells[0] + "T00:00:00Z");
                        else if (!isNaN(cells[0]) && cells[0].length > 8)
                            date = new Date(Number(cells[0]));
                        else date = new Date(cells[0]);
                        price = parseFloat(cells[1]);
                        if (isNaN(date.getTime()) || isNaN(price)) return null;
                        const block = Math.floor(
                            (date.getTime() - genesisTime) /
                                calibratedBlockTimeMs,
                        );
                        return { block, price, date };
                    })
                    .filter((d) => d && d.block >= 0);
            }

            function calculateNormalizedSegmentAngle(
                startBlock,
                startPrice,
                endBlock,
                endPrice,
                maxBlock,
                maxPrice,
            ) {
                if (maxBlock <= 0 || maxPrice <= 0 || endBlock <= startBlock)
                    return 0;
                const startX = startBlock / maxBlock;
                const startY = startPrice / maxPrice;
                const endX = endBlock / maxBlock;
                const endY = endPrice / maxPrice;
                const rise = endY - startY;
                const run = endX - startX;
                if (run === 0) return 90;
                return Math.atan2(rise, run) * (180 / Math.PI);
            }

            function calculateStdDev(arr) {
                if (!arr || arr.length < 2) return 0;
                const n = arr.length;
                const mean = arr.reduce((a, b) => a + b) / n;
                const variance =
                    arr
                        .map((x) => Math.pow(x - mean, 2))
                        .reduce((a, b) => a + b) /
                    (n - 1);
                return Math.sqrt(variance);
            }

            function sigCatStdDev(diff, stdDev) {
                if (stdDev === 0) return { text: "meh", cls: "sig-meh" };
                const devs = diff / stdDev;
                if (devs > 1.5) return { text: "party", cls: "sig-party" };
                if (devs < -1.5)
                    return { text: "no bueno", cls: "sig-no-bueno" };
                if (devs > 0.5) return { text: "peachy", cls: "sig-peachy" };
                if (devs < -0.5) return { text: "watch", cls: "sig-watch" };
                return { text: "meh", cls: "sig-meh" };
            }

            /******************************************************************
             *
             * MAIN APPLICATION LOGIC
             *
             ******************************************************************/
            document.addEventListener("DOMContentLoaded", async () => {
                try {
                    const bhResp = await fetch(
                        "https://blockstream.info/api/blocks/tip/height",
                    );
                    const blockHeight = bhResp.ok
                        ? parseInt(await bhResp.text())
                        : 0;
                    const csvResp = await fetch(
                        `${CONFIG.CSV_URL}?v=${new Date().getTime()}`,
                    );
                    if (!csvResp.ok)
                        throw new Error(
                            `Could not load CSV: ${csvResp.statusText}`,
                        );
                    const csvText = await csvResp.text();
                    const lines = csvText
                        .split("\n")
                        .slice(1)
                        .filter((line) => line.trim());
                    if (lines.length < 2)
                        throw new Error("No valid price data in CSV.");

                    // --- Calibrate Time-to-Block Conversion ---
                    const lastLine = lines[0];
                    const lastCells = lastLine.split(",");
                    let lastTimestamp;
                    if (
                        lastCells[0].includes("-") &&
                        lastCells[0].length === 10
                    )
                        lastTimestamp = new Date(
                            lastCells[0] + "T00:00:00Z",
                        ).getTime();
                    else
                        lastTimestamp = new Date(
                            Number(lastCells[0]),
                        ).getTime();
                    if (isNaN(lastTimestamp))
                        throw new Error(
                            `Could not parse last date: ${lastCells[0]}`,
                        );
                    const daysSinceGenesis =
                        (new Date().getTime() - CONFIG.GENESIS_DATE.getTime()) /
                        (1000 * 60 * 60 * 24);
                    const trueBlocksPerDay =
                        blockHeight > 0 ? blockHeight / daysSinceGenesis : 144;
                    const lastDataBlockHeight =
                        blockHeight -
                        (new Date().getTime() - lastTimestamp) *
                            (trueBlocksPerDay / (24 * 60 * 60 * 1000));
                    if (lastDataBlockHeight <= 0)
                        throw new Error(`Invalid block height calculation.`);
                    const calibratedBlockTimeMs =
                        (lastTimestamp - CONFIG.GENESIS_DATE.getTime()) /
                        lastDataBlockHeight;
                    if (calibratedBlockTimeMs <= 0)
                        throw new Error(`Invalid block time calculation.`);

                    const historical = parseCsvLines(
                        lines,
                        calibratedBlockTimeMs,
                    ).sort((a, b) => a.block - b.block);
                    document.querySelector(
                        ".calculating-overlay",
                    ).style.display = "none";

                    // --- Main App Logic ---
                    const macroEnd = historical[historical.length - 1];
                    const allTimeHigh = Math.max(
                        ...historical.map((d) => d.price),
                    );
                    const latestPrice = macroEnd.price;
                    const latestBlock = macroEnd.block;

                    document.getElementById("blockInfo").style.display = "";
                    document.getElementById("blockInfo").textContent =
                        `Live Block ${blockHeight.toLocaleString()} • Data to Block ${latestBlock.toLocaleString()}`;

                    // --- Calculate Benchmarks ---
                    const currentAngle = calculateNormalizedSegmentAngle(
                        0,
                        0,
                        latestBlock,
                        latestPrice,
                        latestBlock,
                        allTimeHigh,
                    );
                    document.getElementById("currentAngle").innerHTML =
                        `${currentAngle.toFixed(2)}°<span class="tooltip-icon">?</span><div class="tooltip">This is our dynamic benchmark. It's the angle of the line from Bitcoin's origin to its current price, normalized within a 1x1 box (Time vs Price/ATH). Recent momentum is compared against this angle.</div>`;
                    document.getElementById("macroPrice").innerHTML =
                        `$${latestPrice.toLocaleString()}<span class="tooltip-icon-subtle">?</span><div class="tooltip">Bitcoin's price at the most recent data point.</div>`;
                    document.getElementById("athPrice").innerHTML =
                        `$${allTimeHigh.toLocaleString()}<span class="tooltip-icon-subtle">?</span><div class="tooltip">Bitcoin's highest recorded price. This defines the top of our geometric chart.</div>`;

                    // --- Generate and Analyze Consistent Lookbacks ---

                    // 1. Prepare data for quadratic fit
                    const normData = historical.map((d) => ({
                        x: d.block / latestBlock,
                        y: d.price / allTimeHigh,
                    }));

                    // 2. Calculate curvature (a coefficient)
                    const { a: curvature } = calculateQuadraticFit(normData);

                    // Optionally: For debugging, show curvature somewhere
                    console.log("Curvature (a):", curvature);

                    const lookbackPeriods = generateConsistentLookbacks(
                        latestBlock,
                        curvature,
                        CONFIG.GEO_MODEL_CONFIG,
                    );
                    const microGrid = document.getElementById("microGrid");
                    microGrid.innerHTML = "";
                    const analysisResults = [];

                    for (const lookback of lookbackPeriods) {
                        const startBlock = latestBlock - lookback;
                        if (startBlock <= 0) continue;
                        const startRow =
                            historical
                                .slice()
                                .reverse()
                                .find((d) => d.block <= startBlock) ||
                            historical[0];
                        const microAngle = calculateNormalizedSegmentAngle(
                            startRow.block,
                            startRow.price,
                            latestBlock,
                            latestPrice,
                            latestBlock,
                            allTimeHigh,
                        );
                        analysisResults.push({
                            lookback,
                            deviation: microAngle - currentAngle,
                            microAngle,
                        });
                    }

                    // --- Calculate Final Verdict from an unweighted, pure consensus ---
                    const allDiffs = analysisResults.map((r) => r.deviation);
                    // Sort results to display the longest lookback first (on the left)
                    analysisResults.sort((a, b) => b.lookback - a.lookback);
                    const stdDev = calculateStdDev(allDiffs);
                    let consensusScore = 0;

                    for (const res of analysisResults) {
                        const cat = sigCatStdDev(res.deviation, stdDev);
                        const card = document.createElement("div");
                        card.className = "micro-card";
                        card.innerHTML = `<div class="horizon">${res.lookback.toLocaleString()} Block Lookback</div><div class="signal ${cat.cls}">${cat.text}</div><div class="detail">${res.deviation >= 0 ? "↗" : "↘"} ${res.microAngle.toFixed(1)}°</div>`;
                        microGrid.appendChild(card);

                        let statusScore = 0;
                        switch (cat.text) {
                            case "party":
                                statusScore = 2;
                                break;
                            case "peachy":
                                statusScore = 1;
                                break;
                            case "watch":
                                statusScore = -1;
                                break;
                            case "no bueno":
                                statusScore = -2;
                                break;
                        }
                        consensusScore += statusScore; // Unweighted sum for a pure consensus
                    }

                    // Normalize the score. Max possible is 10 (5 * 2). Min is -10.
                    const maxRawScore =
                        CONFIG.GEO_MODEL_CONFIG.numFinalLookbacks * 2;
                    consensusScore =
                        (consensusScore / maxRawScore) *
                        CONFIG.UI_CONFIG.finalScoreScale;

                    // --- Display Final Verdict ---
                    const finalWordEl = document.getElementById("finalWord");
                    if (consensusScore < CONFIG.UI_CONFIG.negativeThreshold) {
                        finalWordEl.textContent = "Yep..";
                        finalWordEl.className = "final-answer verdict-no";
                    } else if (
                        consensusScore > CONFIG.UI_CONFIG.positiveThreshold
                    ) {
                        finalWordEl.textContent = "No.";
                        finalWordEl.className = "final-answer verdict-yep";
                    } else {
                        finalWordEl.textContent = "Yeah Nah";
                        finalWordEl.className = "final-answer verdict-yeah-nah";
                    }
                } catch (err) {
                    document.getElementById("errorStatus").style.display = "";
                    document.getElementById("errorStatus").textContent =
                        "Error loading: " + err.message;
                    console.error(err);
                }
            });
        </script>
    </body>
</html>
