<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>The Geometry of Momentum | Should I Care?</title>
    <link rel="stylesheet" href="css/styles.css">
    <script type="module">
        import { CONFIG } from './js/config.js';
        import * as analysis from './js/analysis.js';
        window.CONFIG = CONFIG;
        window.analysis = analysis;
    </script>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1 class="main-title">The Geometry of Momentum</h1>
        </div>

        <div class="page-intro">
            <div class="callout">
                <h3>A Word of Caution</h3>
                <p>
                    This page visualizes the concepts behind the meter. It is an educational tool,
                    <strong>not an analysis tool</strong>. The main meter
                    was specifically designed to <strong>avoid charts</strong> because they invite
                    subjective interpretation and analysis paralysis. This
                    page exists to prove why that's a worthy goal.
                </p>
            </div>
        </div>

        <div class="chart-header">
            <h2 class="chart-title">The Macro View</h2>
        </div>
        <div class="chart-container">
            <div id="loader">Loading Chart Data...</div>
            <canvas id="macroChart" style="display: none"></canvas>
        </div>
        <div class="explanation">
            <p>This chart shows Bitcoin's entire history normalized into a 1x1 square. This allows us to compare all
                price action on a
                level playing field.</p>
            <ul>
                <li>
                    <div class="legend-swatch" style="background: #374151"></div>
                    <div>
                        <strong>Historical Path:</strong> This is the raw
                        price history, squashed into the box. Its shape is
                        familiar, but its scale is now purely relative.
                    </div>
                </li>
                <li>
                    <div class="legend-swatch" style="border: 2px dashed #adb5bd"></div>
                    <div>
                        <strong>ATH Benchmark (45°):</strong> Represents a
                        perfect, linear journey to the all-time-high price
                        at the current block. It's a theoretical ideal.
                    </div>
                </li>
                <li>
                    <div class="legend-swatch" style="background: #8b5cf6"></div>
                    <div>
                        <strong>Quadratic Fit:</strong> A curve fitted to
                        the entire history. It reveals the overall
                        macro-level acceleration or deceleration of the
                        trend.
                    </div>
                </li>
                <li>
                    <div class="legend-swatch" style="background: #f59e0b"></div>
                    <div>
                        <strong>Macro Trend Line (θ_macro):</strong> This is
                        our key benchmark. It's the actual average velocity
                        from the origin to the present moment, with its angle now explicitly shown.
                    </div>
                </li>
            </ul>
        </div>

        <div class="chart-header">
            <h2 class="chart-title">The Micro View (Zoomed In)</h2>
        </div>
        <div class="chart-container">
            <canvas id="microChart" style="display: none"></canvas>
        </div>
        <div class="explanation">
            <p>Here, we zoom in on the most recent price action. This view demonstrates two key concepts: why human
                chart analysis is flawed and how the meter avoids it.</p>
            <ul>
                <li>
                    <div class="legend-swatch" style="background: #f59e0b"></div>
                    <div>
                        <strong>Perspective is an Illusion:</strong> Notice how the orange <strong>Macro Trend
                            Line</strong>, which looked steep in the macro view, now appears almost flat. Your
                        perception of its steepness is an illusion created by the zoom level. The meter avoids this by
                        using raw angles, not visual interpretation.
                    </div>
                </li>
                <li>
                    <div class="legend-swatch" style="background: #059669"></div>
                    <div>
                        <strong>Annotated Deviations (Δ):</strong> Each colored horizon line now has an annotation
                        showing its final calculated momentum deviation. This value represents the *true* acceleration
                        or deceleration of that timeframe relative to the next longest one. This is the exact value used
                        to generate the "Peachy" or "No Bueno" status on the main meter.
                    </div>
                </li>
                <li>
                    <div class="legend-swatch"
                        style="background-color: #059669; border-radius: 50%; width: 20px; height: 20px; color: white; text-align: center; font-weight: bold; line-height: 20px;">
                        ①</div>
                    <div>
                        <strong>Chirp-Selected Lookbacks:</strong> The starting point of each horizon is connected to a
                        color-coded marker on the x-axis. These points are derived from the peaks of a "chirp" signal
                        whose frequency changes based on the market's long-term acceleration and trend health.
                    </div>
                </li>
            </ul>
        </div>

        <div class="footer">
            <div class="footer-nav">
                <a href="index.html">&larr; Back to the Meter</a>
                <a href="wtfit.html">Read Full Explanation &rarr;</a>
            </div>
        </div>
    </div>

    <script type="module">
        import {
            parseCsvLines,
            calculateQuadraticFit,
            generateLookbacks,
            calculateNormalizedSegmentAngle,
            calculateStdDev,
            sigCatStdDev,
        } from './js/analysis.js';


        // --- STYLING & DRAWING (No changes needed here) ---

        const chartColors = {
            grid: "#e9ecef", text: "#6b7280", path: "#374151",
            ath: "#adb5bd", macro: "#f59e0b", fit: "#8b5cf6",
            "sig-party": "#059669", "sig-peachy": "#d97706",
            "sig-meh": "#6b7280", "sig-watch": "#2563eb",
            "sig-no-bueno": "#dc2626",
        };

        function drawMacroChart(canvas, chartData) {
            // This function is correct, no changes needed.
            const ctx = canvas.getContext("2d");
            const padding = 60;
            const { normalizedHistorical, fit, currentAngle, athBlock } = chartData;
            const chartWidth = canvas.width - 2 * padding;
            const chartHeight = canvas.height - 2 * padding;
            const mapCoords = (x, y) => ({ x: padding + x * chartWidth, y: canvas.height - padding - y * chartHeight });

            const latestPoint = normalizedHistorical[normalizedHistorical.length - 1];

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = chartColors.grid;
            ctx.fillStyle = chartColors.text;
            ctx.font = "12px sans-serif";
            ctx.lineWidth = 1;

            for (let i = 0; i <= 4; i++) {
                const frac = i / 4;
                let p = mapCoords(0, frac);
                ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x + chartWidth, p.y); ctx.stroke();
                ctx.textAlign = "right";
                ctx.fillText(`${(frac * 100).toFixed(0)}%`, p.x - 10, p.y + 4);
                p = mapCoords(frac, 0);
                ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x, p.y - chartHeight); ctx.stroke();
                ctx.textAlign = "center";
                ctx.fillText(`${(frac * 100).toFixed(0)}%`, p.x, p.y + 20);
            }
            ctx.textAlign = "center";
            ctx.fillText("Age in Blocks", canvas.width / 2, canvas.height - 15);
            ctx.save();
            ctx.translate(15, canvas.height / 2); ctx.rotate(-Math.PI / 2);
            ctx.fillText("Price as % of All-Time High", 0, 0);
            ctx.restore();

            ctx.strokeStyle = chartColors.ath; ctx.lineWidth = 2; ctx.setLineDash([5, 5]);
            let p1 = mapCoords(0, 0), p2 = mapCoords(1, 1);
            ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
            ctx.setLineDash([]);

            ctx.strokeStyle = chartColors.fit; ctx.lineWidth = 2.5;
            ctx.beginPath();
            let p = mapCoords(0, fit.c);
            ctx.moveTo(p.x, p.y);
            for (let i = 1; i <= 100; i++) {
                const x = i / 100;
                const y = fit.a * x * x + fit.b * x + fit.c;
                p = mapCoords(x, y); ctx.lineTo(p.x, p.y);
            }
            ctx.stroke();

            ctx.strokeStyle = chartColors.path; ctx.lineWidth = 1.5;
            ctx.beginPath();
            p1 = mapCoords(normalizedHistorical[0].x, normalizedHistorical[0].y);
            ctx.moveTo(p1.x, p1.y);
            for (const point of normalizedHistorical) {
                p2 = mapCoords(point.x, point.y); ctx.lineTo(p2.x, p2.y);
            }
            ctx.stroke();

            const origin = mapCoords(0, 0);
            const endOfTrend = mapCoords(latestPoint.x, latestPoint.y);

            ctx.strokeStyle = chartColors.macro;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(origin.x, origin.y);
            ctx.lineTo(endOfTrend.x, endOfTrend.y);
            ctx.stroke();

            const angleRad = currentAngle * (Math.PI / 180);
            const arcRadius = chartWidth * 0.20;
            ctx.beginPath();
            ctx.arc(origin.x, origin.y, arcRadius, 0, -angleRad, true);
            ctx.setLineDash([2, 4]);
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.setLineDash([]);

            const labelAngle = -angleRad / 2;
            const labelRadius = arcRadius + 15;
            ctx.fillStyle = chartColors.text;
            ctx.font = "12px sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(
                `${currentAngle.toFixed(1)}°`,
                origin.x + labelRadius * Math.cos(labelAngle),
                origin.y + labelRadius * Math.sin(labelAngle)
            );
        }

        function drawMicroChart(canvas, chartData) {
            const ctx = canvas.getContext("2d");
            const padding = { top: 60, right: 60, bottom: 60, left: 80 };
            // Destructure latestBlock, which we now pass in
            const { normalizedHistorical, historical, momentumDeltas, athBlock, allTimeHigh, latestBlock } = chartData;

            const longestLookback = Math.max(...momentumDeltas.map((r) => r.lookback));
            const zoomWindowBlocks = longestLookback * 1.15;
            // Use latestBlock for zooming window calculation for better relevance
            const xMinNorm = (latestBlock - zoomWindowBlocks) / athBlock; 
            const relevantHistory = normalizedHistorical.filter((p) => p.x >= xMinNorm);
            if (relevantHistory.length === 0) return;

            const yMinNorm = Math.min(...relevantHistory.map((p) => p.y)) * 0.98;
            const yMaxNorm = Math.max(...relevantHistory.map((p) => p.y)) * 1.02;
            const chartWidth = canvas.width - padding.left - padding.right;
            const chartHeight = canvas.height - padding.top - padding.bottom;

            const mapCoords = (xNorm, yNorm) => {
                const zoomedX = (xNorm - xMinNorm) / (1 - xMinNorm);
                const zoomedY = (yNorm - yMinNorm) / (yMaxNorm - yMinNorm);
                return { x: padding.left + zoomedX * chartWidth, y: canvas.height - padding.bottom - zoomedY * chartHeight };
            };

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // ... (rest of the grid/axis drawing is fine) ...
            ctx.font = "12px sans-serif";
            ctx.strokeStyle = chartColors.grid; ctx.fillStyle = chartColors.text; ctx.lineWidth = 1;

            const boxStart = mapCoords(xMinNorm, yMinNorm);
            const boxEnd = mapCoords(1, yMaxNorm);
            ctx.strokeRect(boxStart.x, boxEnd.y, boxEnd.x - boxStart.x, boxStart.y - boxEnd.y);
            ctx.textAlign = "right";
            for (let i = 0; i <= 4; i++) {
                const yNorm = yMinNorm + (i * (yMaxNorm - yMinNorm)) / 4;
                const p = mapCoords(xMinNorm, yNorm);
                ctx.fillText(`$${(yNorm * allTimeHigh).toLocaleString(undefined, { maximumFractionDigits: 0, })}`, p.x - 10, p.y + 4);
            }
            ctx.textAlign = "center";
            for (let i = 0; i <= 4; i++) {
                const xNorm = xMinNorm + (i * (1 - xMinNorm)) / 4;
                const p = mapCoords(xNorm, yMinNorm);
                ctx.fillText(`${(xNorm * athBlock).toLocaleString(undefined, { maximumFractionDigits: 0, })}`, p.x, p.y + 20);
            }


            ctx.strokeStyle = chartColors.path; ctx.lineWidth = 2;
            ctx.beginPath();
            let firstPoint = true;
            for (const point of normalizedHistorical) {
                if (point.x >= xMinNorm) {
                    const p = mapCoords(point.x, point.y);
                    if (firstPoint) { ctx.moveTo(p.x, p.y); firstPoint = false; }
                    else { ctx.lineTo(p.x, p.y); }
                }
            }
            ctx.stroke();

            const latestPointNorm = normalizedHistorical[normalizedHistorical.length - 1];
            const macroSlope = latestPointNorm.y / latestPointNorm.x;
            const macroYatXmin = macroSlope * xMinNorm;
            let p1 = mapCoords(xMinNorm, macroYatXmin);
            let p2 = mapCoords(latestPointNorm.x, latestPointNorm.y);
            ctx.strokeStyle = chartColors.macro; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();

            momentumDeltas.sort((a, b) => b.lookback - a.lookback);

            momentumDeltas.forEach((horizon, index) => {
                // ==========================================================
                // ========= THE CRITICAL BUG FIX IS HERE ===================
                // ==========================================================
                // We must use 'latestBlock' as the reference, not 'athBlock',
                // to match how the angle was originally calculated.
                const startBlock = latestBlock - horizon.lookback;
                // ==========================================================

                const startRow = historical.slice().reverse().find((d) => d.block <= startBlock) || historical[0];
                const startPointNorm = { x: startRow.block / athBlock, y: startRow.price / allTimeHigh };

                p1 = mapCoords(startPointNorm.x, startPointNorm.y);
                p2 = mapCoords(latestPointNorm.x, latestPointNorm.y);
                const horizonColor = chartColors[horizon.status.cls];

                ctx.strokeStyle = horizonColor;
                ctx.lineWidth = 2.5;
                ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();

                if (startPointNorm.x >= xMinNorm) {
                    const xAxisPoint = mapCoords(startPointNorm.x, yMinNorm);

                    ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(xAxisPoint.x, xAxisPoint.y);
                    ctx.strokeStyle = horizonColor; ctx.lineWidth = 1; ctx.setLineDash([2, 3]); ctx.stroke(); ctx.setLineDash([]);

                    ctx.beginPath(); ctx.arc(xAxisPoint.x, xAxisPoint.y, 10, 0, 2 * Math.PI);
                    ctx.fillStyle = horizonColor; ctx.fill();

                    ctx.fillStyle = "#FFFFFF"; ctx.font = "bold 12px sans-serif"; ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(String.fromCharCode(0x2460 + index), xAxisPoint.x, xAxisPoint.y);

                    const midX = (p1.x + p2.x) / 2;
                    const midY = (p1.y + p2.y) / 2;
                    ctx.fillStyle = horizonColor;
                    ctx.font = "bold 13px sans-serif";
                    ctx.save();
                    ctx.translate(midX, midY);
                    const lineAngleRad = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                    ctx.rotate(lineAngleRad);
                    ctx.textAlign = "center";
                    ctx.textBaseline = "bottom";
                    ctx.fillText(`Δ = ${horizon.deviation.toFixed(1)}°`, 0, -8);
                    ctx.restore();
                }
            });
        }


        // --- MAIN LOGIC (Correction in analysisData object) ---

        document.addEventListener("DOMContentLoaded", () => {
            const runAll = async () => {
                try {
                    // ... (initial data loading is fine) ...
                    const loader = document.getElementById("loader");
                    loader.style.display = "block";
                    loader.textContent = "Loading Chart Data...";

                    const bhResp = await fetch("https://blockstream.info/api/blocks/tip/height");
                    const blockHeight = bhResp.ok ? parseInt(await bhResp.text()) : 0;
                    const csvResp = await fetch(`${window.CONFIG.CSV_URL}?v=${new Date().getTime()}`);
                    if (!csvResp.ok) throw new Error(`Could not load CSV: ${csvResp.statusText}`);
                    const csvText = await csvResp.text();
                    const lines = csvText.split("\n").slice(1).filter((line) => line.trim());

                    const lastLine = lines[0];
                    const lastCells = lastLine.split(",");
                    const lastTimestamp = lastCells[0].includes("-") && lastCells[0].length === 10
                        ? new Date(lastCells[0] + "T00:00:00Z").getTime()
                        : new Date(Number(lastCells[0])).getTime();
                    const daysSinceGenesis = (Date.now() - window.CONFIG.GENESIS_DATE.getTime()) / 86_400_000;
                    const trueBlocksPerDay = blockHeight > 0 ? blockHeight / daysSinceGenesis : 144;
                    const lastDataBlockHeight = blockHeight - (Date.now() - lastTimestamp) * (trueBlocksPerDay / 86_400_000);
                    const calibratedBlockTimeMs = (lastTimestamp - window.CONFIG.GENESIS_DATE.getTime()) / lastDataBlockHeight;

                    const historical = parseCsvLines(lines, calibratedBlockTimeMs).sort((a, b) => a.block - b.block);

                    if (historical.length < 2) throw new Error("Not enough historical data.");

                    const allTimeHigh = Math.max(...historical.map((d) => d.price));
                    const latestBlock = historical[historical.length - 1].block;
                    const latestPrice = historical[historical.length - 1].price;
                    const athBlock = historical.find(d => d.price === allTimeHigh)?.block || latestBlock;

                    const normalizedHistorical = historical.map((d) => ({ x: d.block / athBlock, y: d.price / allTimeHigh }));

                    const currentAngle = calculateNormalizedSegmentAngle(0, 0, latestBlock, latestPrice, athBlock, allTimeHigh);
                    const angularRatio = currentAngle / 45.0;
                    const { a: curvature } = calculateQuadraticFit(normalizedHistorical);

                    const lookbacks = generateLookbacks(latestBlock, curvature, angularRatio, window.CONFIG.GEO_MODEL_CONFIG);

                    // Using the improved, non-cascading logic from before
                    const momentumDeltas = [];
                    for (const lookback of lookbacks) {
                        const startBlock = latestBlock - lookback;
                        if (startBlock <= 0) continue;
                        
                        const startRow = historical.slice().reverse().find(d => d.block <= startBlock) || historical[0];
                        const microAngle = calculateNormalizedSegmentAngle(startRow.block, startRow.price, latestBlock, latestPrice, athBlock, allTimeHigh);
                        
                        const deviation = microAngle - currentAngle;
                        
                        momentumDeltas.push({ lookback, deviation });
                    }

                    const allDiffs = momentumDeltas.map((r) => r.deviation);
                    const stdDevVal = calculateStdDev(allDiffs);
                    momentumDeltas.forEach((res) => { res.status = sigCatStdDev(res.deviation, stdDevVal); });

                    // ========= ADD latestBlock TO THE DATA OBJECT =========
                    const analysisData = {
                        historical, normalizedHistorical, momentumDeltas, fit: calculateQuadraticFit(normalizedHistorical),
                        athBlock, allTimeHigh, currentAngle, latestBlock // <-- Pass latestBlock here
                    };
                    // ======================================================

                    const macroCanvas = document.getElementById("macroChart");
                    const microCanvas = document.getElementById("microChart");
                    // ... (rest of the code is fine) ...
                    const container = macroCanvas.parentElement;
                    const canvasSize = container.getBoundingClientRect().width;
                    macroCanvas.width = macroCanvas.height = canvasSize;
                    microCanvas.width = microCanvas.height = canvasSize;

                    loader.style.display = "none";
                    macroCanvas.style.display = "block";
                    microCanvas.style.display = "block";

                    drawMacroChart(macroCanvas, analysisData);
                    drawMicroChart(microCanvas, analysisData);

                } catch (err) {
                    loader.textContent = "Error loading chart: " + err.message;
                    console.error(err);
                }
            };

            runAll();
            let resizeTimer;
            window.addEventListener("resize", () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(runAll, 250);
            });
        });
    </script>
</body>

</html>