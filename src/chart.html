<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>The Geometry of Momentum | Should I Give a Fuck?</title>
    <link rel="stylesheet" href="/css/styles.css">
    <script type="module">
        import { CONFIG } from '/js/config.js';
        import * as analysis from '/js/analysis.js';
        window.CONFIG = CONFIG;
        window.analysis = analysis;
    </script>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1 class="main-title">The Geometry of Momentum</h1>
        </div>

        <div class="page-intro">
            <div class="callout">
                <h3>A Word of Caution</h3>
                <p>
                    This page visualizes the concepts behind the meter. It is an educational tool,
                    <strong>not an analysis tool</strong>. The main meter
                    was specifically designed to <strong>avoid charts</strong> because they invite
                    subjective interpretation and analysis paralysis. This
                    page exists to prove why that's a worthy goal.
                </p>
            </div>
        </div>

        <!-- MACRO VIEW --------------------------------------------------------->
        <div class="chart-header">
            <h2 class="chart-title">The Macro View</h2>
        </div>
        <div class="chart-container">
            <div id="loader">Loading Chart Data...</div>
            <canvas id="macroChart" style="display: none"></canvas>
        </div>
        <div class="explanation">
            <p>This chart shows Bitcoin's entire history normalized into a 1x1 square.</p>
            <ul> <!-- legend items unchanged --></ul>
        </div>

        <!-- MICRO VIEW --------------------------------------------------------->
        <div class="chart-header">
            <h2 class="chart-title">The Micro View (Zoomed In)</h2>
        </div>
        <div class="chart-container">
            <canvas id="microChart" style="display: none"></canvas>
        </div>
        <div class="explanation">
            <p>Here, we zoom in on the most recent price action …</p>
            <ul> <!-- legend items unchanged --></ul>
        </div>

        <!-- CHIRP VIEW --------------------------------------------------------->
        <div class="chart-header">
            <h2 class="chart-title">The Chirp Function (Debug Panel)</h2>
        </div>
        <div class="chart-controls" style="margin: 0 0 10px 10px;">
            <label for="curvatureSlider">Adjust Curvature&nbsp;</label>
            <input type="range" id="curvatureSlider" min="-0.004" max="0.004" step="0.0001" value="0">
            <span id="curvatureValue">0.0000</span>
        </div>
        <div class="chart-container">
            <canvas id="chirpChart" style="display: none"></canvas>
        </div>
        <div class="explanation">
            <p>
                The purple wave is the <em>chirp</em> used to pick dynamic horizons.
                Vertical orange markers are the horizons chosen at the current curvature.
                Move the slider to see how a steeper or flatter macro curve
                squeezes or spreads the peaks.
            </p>
        </div>

        <!-- FOOTER ------------------------------------------------------------->
        <div class="footer">
            <div class="footer-nav">
                <a href="/index.html">&larr; Back to the Meter</a>
                <a href="/wtfit.html">Read Full Explanation &rarr;</a>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script type="module">
        import {
            parseCsvLines,
            calculateQuadraticFit,
            generateLookbacksAlongMacroActual,
            calculateNormalizedSegmentAngle,
            calculateStdDev,
            sigCatStdDev,
            normalizeMetric               // added export
        } from '/js/analysis.js';

        // ---------------------------------------------------------------------
        // COLOURS
        // ---------------------------------------------------------------------
        const chartColors = {
            grid: "#e9ecef",
            text: "#6b7280",
            path: "#374151",
            ath:  "#adb5bd",
            macro:"#f59e0b",
            fit:  "#8b5cf6",
            "sig-party":    "#059669",
            "sig-peachy":   "#d97706",
            "sig-meh":      "#6b7280",
            "sig-watch":    "#2563eb",
            "sig-no-bueno": "#dc2626",
            chirp:          "#a855f7",
            peak:           "#f59e0b",
        };

        // ---------------------------------------------------------------------
        // DRAWING HELPERS   (macro & micro draw functions unchanged)
        // ---------------------------------------------------------------------
        // … drawMacroChart(...) and drawMicroChart(...) stay as in your file …

        function drawChirpChart(canvas, params) {
            const { f0, k, peaks, extraCurve } = params;
            const ctx = canvas.getContext("2d");
            const pad = 50;
            const w   = canvas.width  - 2 * pad;
            const h   = canvas.height - 2 * pad;

            // clear
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // grid
            ctx.strokeStyle = chartColors.grid;
            ctx.lineWidth   = 1;
            ctx.beginPath();
            for (let i = 0; i <= 4; i++) {
                const y = pad + (i / 4) * h;
                ctx.moveTo(pad, y);
                ctx.lineTo(pad + w, y);
            }
            ctx.stroke();

            // axes labels
            ctx.fillStyle = chartColors.text;
            ctx.font = "12px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText("Normalised time x (0 → 1)", pad + w / 2, canvas.height - 10);
            ctx.save();
            ctx.translate(15, pad + h / 2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText("sin (2π·phase(x))", 0, 0);
            ctx.restore();

            // chirp wave
            ctx.strokeStyle = chartColors.chirp;
            ctx.lineWidth   = 2;
            ctx.beginPath();
            for (let i = 0; i <= 400; i++) {
                const x = i / 400;
                const phase = f0 * x + 0.5 * k * x * x;   // integral of freq
                const y = 0.5 - 0.45 * Math.sin(2 * Math.PI * phase); // centred in box
                const cx = pad + x * w;
                const cy = pad + y * h;
                if (i === 0) ctx.moveTo(cx, cy);
                else         ctx.lineTo(cx, cy);
            }
            ctx.stroke();

            // peaks
            ctx.strokeStyle = chartColors.peak;
            ctx.lineWidth   = 2;
            ctx.setLineDash([4,3]);
            peaks.forEach((xNorm, idx) => {
                const cx = pad + xNorm * w;
                ctx.beginPath();
                ctx.moveTo(cx, pad);
                ctx.lineTo(cx, pad + h);
                ctx.stroke();

                ctx.setLineDash([]);
                ctx.fillStyle = chartColors.text;
                ctx.textAlign = "center";
                ctx.fillText(idx+1, cx, pad + h + 15);
                ctx.setLineDash([4,3]);
            });
            ctx.setLineDash([]);

            // title / info
            ctx.fillStyle = chartColors.text;
            ctx.textAlign = "left";
            ctx.fillText(`f₀ = ${f0.toFixed(2)} cycles,  k = ${k.toFixed(2)},  Δcurvature = ${extraCurve.toFixed(4)}`,
                         pad, pad - 15);
        }

        // ---------------------------------------------------------------------
        // MAIN
        // ---------------------------------------------------------------------
        document.addEventListener("DOMContentLoaded", async () => {
            // fetch & analyse (macro + micro) ----------------------------------
            const runFullAnalysis = async () => { /* identical to previous version, truncated for brevity */ };

            // compact: we just call runFullAnalysis once at load, it assigns:
            //  - curvature, macroActualSlope, latestBlock, etc. to outer scope vars
            //  - and draws macro & micro charts
            let curvature, macroActualSlope, latestBlock, allTimeHigh;
            await (async function() {
                // full analysis copied from earlier (omitted here to save space)
                // at the end we set the needed vars:
                curvature          = /* value from quadratic fit */;
                macroActualSlope   = /* latestPrice / allTimeHigh */;
                latestBlock        = /* latest block height */;
                allTimeHigh        = /* ATH price */;
            })();

            // CHIRP slider & draw ---------------------------------------------
            const chirpCanvas = document.getElementById("chirpChart");
            const slider      = document.getElementById("curvatureSlider");
            const sliderLbl   = document.getElementById("curvatureValue");
            const size        = chirpCanvas.parentElement.getBoundingClientRect().width;
            chirpCanvas.width = chirpCanvas.height = size;
            chirpCanvas.style.display = "block";

            const {
                flatteningLookbackConfig,
                steepeningLookbackConfig,
                curvatureStats,
                slopeStats,
                curvatureSensitivity,
                slopeSensitivity,
                slopeWeight,
                lookbackRangeDenominator
            } = CONFIG.GEO_MODEL_CONFIG;

            const computeChirpParams = (extra) => {
                const effCurv = curvature + extra;

                // replicate α calc (normalised curvature + slope blend)
                const curvInput  = normalizeMetric(effCurv, curvatureStats, curvatureSensitivity);
                const slopeInput = normalizeMetric(macroActualSlope, slopeStats,  slopeSensitivity);
                const blend      = curvInput * (1 - slopeWeight) + slopeInput * slopeWeight;
                const alpha      = (blend + 1) / 2;

                const startCycles = flatteningLookbackConfig.startCycles * (1 - alpha) +
                                    steepeningLookbackConfig.startCycles * alpha;
                const endCycles   = flatteningLookbackConfig.endCycles   * (1 - alpha) +
                                    steepeningLookbackConfig.endCycles   * alpha;

                const f0 = startCycles;
                const k  = endCycles - startCycles;

                // use generateLookbacks to get the peaks → convert to x positions
                const lookbacks = generateLookbacksAlongMacroActual(
                    latestBlock,
                    effCurv,
                    CONFIG.GEO_MODEL_CONFIG,
                    macroActualSlope
                );
                const maxRange  = latestBlock * lookbackRangeDenominator;
                const peaks = lookbacks.map(L => L / maxRange);

                return { f0, k, peaks, extraCurve: extra };
            };

            const renderChirp = (delta=0) => {
                sliderLbl.textContent = Number(delta).toFixed(4);
                const params = computeChirpParams(Number(delta));
                drawChirpChart(chirpCanvas, params);
            };

            slider.addEventListener("input", (e) => renderChirp(e.target.value));
            renderChirp(0); // initial draw
        });
    </script>
</body>

</html>
