<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Bitcoin "Should I Care" Meter</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="css/styles.css">

    <!-- Expose config & helpers for console debugging -->
    <script type="module">
        import { CONFIG } from './js/config.js';
        import * as analysis from './js/analysis.js';
        window.CONFIG = CONFIG;
        window.analysis = analysis;
    </script>
</head>

<body>
    <div class="container">
        <!-- ───────────────────────────── HEADER ────────────────────────────── -->
        <div class="header">
            <div class="weekly-movement" id="weeklyMovement"></div>
            <h1 class="main-title" id="mainTitle">Should I Care?</h1>
            <div class="block-info" id="blockInfo" style="display: none"></div>
        </div>

        <!-- ───────────────────────────── CONTENT ───────────────────────────── -->
        <div class="content">
            <!-- ===== MACRO VIEW ===== -->
            <div class="section">
                <div class="section-title">Macro View - HOW IS BITCOIN DOING RELATIVE TO ITS ENTIRE HISTORY?</div>
                <table class="macro-table">
                    <tr>
                        <td>
                            <span class="label">Current Trend Angle</span>
                            <span class="value" id="currentAngle">—<span class="tooltip-icon">?</span>
                                <div class="tooltip">
                                    The angle of the line from Bitcoin's origin
                                    to its current price, normalized within
                                    a 1×1 box (Time vs Price/ATH). This defines
                                    the health of the macro trend.
                                </div>
                            </span>
                        </td>
                        <td>
                            <span class="label">ATH Benchmark</span>
                            <span class="value" id="benchmarkAngle">45°<span class="tooltip-icon">?</span>
                                <div class="tooltip">
                                    The theoretical ideal: a perfect straight
                                    line from origin to the All‑Time‑High price
                                    on the normalized chart.
                                </div>
                            </span>
                        </td>
                        <td>
                            <span class="label">Current Price</span>
                            <span class="value" id="macroPrice">—<span class="tooltip-icon-subtle">?</span>
                                <div class="tooltip">
                                    Bitcoin's price. Updated live if possible,
                                    otherwise from the latest data point.
                                </div>
                            </span>
                        </td>
                        <td>
                            <span class="label">All Time High</span>
                            <span class="value" id="athPrice">—<span class="tooltip-icon-subtle">?</span>
                                <div class="tooltip">
                                    Bitcoin's highest recorded price. This
                                    defines the top of our geometric chart.
                                </div>
                            </span>
                        </td>
                    </tr>
                </table>
            </div>

            <!-- ===== MICRO VIEW ===== -->
            <div class="section">
                <div class="section-title">
                    Micro View - How is Bitcoin's momentum changing across time horizons?
                </div>

                <!-- populated by JS -->
                <div class="micro-grid" id="microGrid">
                    <div class="calculating-overlay">
                        Calibrating &amp; Analyzing...
                    </div>
                </div>
            </div>
        </div>

        <!-- ───────────────────────────── VERDICT ───────────────────────────── -->
        <div class="final-word">
            <div class="final-question">So, should you Care about the price of Bitcoin?</div>
            <div class="final-answer" id="finalWord">...</div>
        </div>

        <!-- ───────────────────────────── FOOTER ────────────────────────────── -->
        <div class="footer">
            <div class="footer-text">
                Each horizon shows <strong>Δ&nbsp;momentum</strong> relative to both the
                overall macro trend and the next‑longer window.<br />
                This measures true acceleration, corrected for geometric distortion.
            </div>
            <a href="charts.html" class="footer-link">See the geometric charts →</a>
            <div class="error" id="errorStatus" style="display: none"></div>
        </div>
    </div>

    <!-- ───────────────────────────── MAIN SCRIPT ──────────────────────────── -->
    <script type="module">
        import {
            parseCsvLines,
            calculateQuadraticFit,
            generateLookbacks,
            calculateNormalizedSegmentAngle,
            calculateStdDev,
            sigCatStdDev
        } from './js/analysis.js';

        /* ------------------------------------------------------------------ */
        /* Helpers                                                            */
        /* ------------------------------------------------------------------ */
        async function getLiveBitcoinPrice() {
            try {
                const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd');
                if (!response.ok) throw new Error('CoinGecko API request failed');
                const data = await response.json();
                return data.bitcoin.usd;
            } catch (error) {
                console.warn('Could not fetch live price, will use latest price from CSV.', error.message);
                return null;
            }
        }

        /* ------------------------------------------------------------------ */
        /* Main                                                               */
        /* ------------------------------------------------------------------ */
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                /* ----------------------- Data fetch & calibration --------- */
                const bhResp = await fetch('https://blockstream.info/api/blocks/tip/height');
                const blockHeight = bhResp.ok ? parseInt(await bhResp.text()) : 0;

                const csvResp = await fetch(`${window.CONFIG.CSV_URL}?v=${Date.now()}`);
                if (!csvResp.ok) throw new Error(`Could not load CSV: ${csvResp.statusText}`);

                const lines = (await csvResp.text())
                    .split('\n')
                    .slice(1)
                    .filter(l => l.trim());
                if (lines.length < 2) throw new Error('No valid price data in CSV.');

                const lastCells = lines[0].split(',');
                const lastTimestamp = lastCells[0].includes('-') && lastCells[0].length === 10
                    ? new Date(lastCells[0] + 'T00:00:00Z').getTime()
                    : new Date(Number(lastCells[0])).getTime();
                if (isNaN(lastTimestamp)) throw new Error(`Could not parse last date: ${lastCells[0]}`);

                const daysSinceGenesis = (Date.now() - window.CONFIG.GENESIS_DATE.getTime()) / 86_400_000;
                const trueBlocksPerDay = blockHeight > 0 ? blockHeight / daysSinceGenesis : 144;
                const lastDataBlockHeight = blockHeight - (Date.now() - lastTimestamp) * (trueBlocksPerDay / 86_400_000);
                const calibratedBlockTimeMs = (lastTimestamp - window.CONFIG.GENESIS_DATE.getTime()) / lastDataBlockHeight;
                if (calibratedBlockTimeMs <= 0) throw new Error('Invalid block time calculation.');

                const historical = parseCsvLines(lines, calibratedBlockTimeMs).sort((a, b) => a.block - b.block);
                document.querySelector('.calculating-overlay').style.display = 'none';

                /* ----------------------- Macro metrics -------------------- */
                const macroEnd = historical[historical.length - 1];
                const allTimeHigh = Math.max(...historical.map(d => d.price));
                const livePrice = await getLiveBitcoinPrice();
                const latestPrice = macroEnd.price;
                const displayPrice = livePrice || latestPrice;
                const latestBlock = macroEnd.block;
                const athBlock = historical.find(d => d.price === allTimeHigh)?.block || latestBlock;

                // Show live/data height
                const blockInfoEl = document.getElementById('blockInfo');
                blockInfoEl.textContent = `Live Block ${blockHeight.toLocaleString()} • Data to Block ${latestBlock.toLocaleString()}`;
                blockInfoEl.style.display = '';

                // Weekly movement headline
                const weekAgoBlock = latestBlock - 7 * trueBlocksPerDay;
                const weekAgoData = historical.slice().reverse().find(d => d.block <= weekAgoBlock);
                if (weekAgoData) {
                    const pct = ((displayPrice - weekAgoData.price) / weekAgoData.price) * 100;
                    const up = pct >= 0;
                    document.getElementById('weeklyMovement').innerHTML = `BTC is <span class="${up ? 'velocity-up' : 'velocity-down'}">${up ? 'up' : 'down'} ${Math.abs(pct).toFixed(1)}%</span> this week`;
                }

                // Macro angle & price boxes
                const currentAngle = calculateNormalizedSegmentAngle(0, 0, latestBlock, displayPrice, athBlock, allTimeHigh);
                document.getElementById('currentAngle').innerHTML = `${currentAngle.toFixed(2)}°<span class="tooltip-icon">?</span><div class="tooltip">The angle of the line from Bitcoin's origin to its current price, normalised within a 1×1 box (Time vs Price/ATH). This defines the macro trend.</div>`;
                document.getElementById('macroPrice').innerHTML = `$${displayPrice.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}<span class="tooltip-icon-subtle">?</span><div class="tooltip">Bitcoin's live price (or latest data point).</div>`;
                document.getElementById('athPrice').innerHTML = `$${allTimeHigh.toLocaleString()}<span class="tooltip-icon-subtle">?</span><div class="tooltip">Bitcoin's highest recorded price.</div>`;

                /* ----------------------- Look‑back generation ------------- */
                const normData = historical.map(d => ({ x: d.block / athBlock, y: d.price / allTimeHigh }));
                const { a: curvature } = calculateQuadraticFit(normData);
                const angularRatio = currentAngle / 45.0;

                const lookbacks = generateLookbacks(latestBlock, curvature, angularRatio, window.CONFIG.GEO_MODEL_CONFIG).sort((a, b) => b - a);
                const Lmax = Math.max(...lookbacks);

                /* ----------------------- NEW: slopes & deltas ------------- */
                const macroSlope = latestPrice / latestBlock;  // $ per block over whole history
                let prevMicroSlope = null;                      // for Δ vs previous window

                const microGrid = document.getElementById('microGrid');
                microGrid.innerHTML = '';

                const momentumDeltas = [];  // still used for consensus score

                for (const lookback of lookbacks) {
                    const startBlock = latestBlock - lookback;
                    if (startBlock <= 0) continue;
                    const startRow = historical.slice().reverse().find(d => d.block <= startBlock) || historical[0];

                    const microAngle = calculateNormalizedSegmentAngle(startRow.block, startRow.price,
                        latestBlock, displayPrice,
                        athBlock, allTimeHigh);
                    const blockDiff = latestBlock - startRow.block;
                    const priceDiff = displayPrice - startRow.price;
                    const microSlope = priceDiff / blockDiff;                 // $ per block
                    const deltaMacro = microSlope - macroSlope;               // acceleration vs macro slope
                    const deltaPrev = prevMicroSlope === null ? null : microSlope - prevMicroSlope; // vs next‑longer win

                    // ---------- keep original deviation logic ----------
                    const deviation = microAngle - currentAngle;
                    momentumDeltas.push({ lookback, deviation, momentum: microSlope });

                    // ---------- Card rendering ----------
                    const cat = sigCatStdDev(deviation, calculateStdDev(momentumDeltas.map(r => r.deviation)) || 1);
                    const dailyDeltaMacro = deltaMacro * trueBlocksPerDay;
                    const dailyDeltaPrev = deltaPrev === null ? null : deltaPrev * trueBlocksPerDay;

                    const card = document.createElement('div');
                    card.className = 'micro-card';

                    // Micro card structure
                    card.innerHTML = `
                        <div class="signal ${cat.cls}">${cat.text}</div>
                        <div class="main-metric">
                            <span class="arrow">${deviation >= 0 ? '↗' : '↘'}</span>
                            <span class="value">${Math.abs(deviation).toFixed(2)}°<span class="tooltip-icon">?</span>
                                <div class="tooltip">Angle deviation from the macro trend over this horizon.</div>
                            </span>
                        </div>
                        <div class="horizon">Over ${lookback.toLocaleString()} Blocks</div>
                        <div class="deltas">
                            <div class="delta-row">
                                <span class="delta-label">vs. Macro:</span>
                                <span class="delta-value ${dailyDeltaMacro >= 0 ? 'positive' : 'negative'}">${dailyDeltaMacro >= 0 ? '+' : ''}$${Math.abs(dailyDeltaMacro).toFixed(2)}/day</span>
                            </div>
                            ${deltaPrev === null ? '' : `
                            <div class="delta-row">
                                <span class="delta-label">vs. Prev:</span>
                                <span class="delta-value ${dailyDeltaPrev >= 0 ? 'positive' : 'negative'}">${dailyDeltaPrev >= 0 ? '+' : ''}$${Math.abs(dailyDeltaPrev).toFixed(2)}/day</span>
                            </div>`}
                        </div>
                    `;

                    microGrid.appendChild(card);

                    prevMicroSlope = microSlope; // set for the next (shorter) window
                }

                /* ----------------------- Consensus verdict --------------- */
                // re‑use existing logic for consensus score based on momentumDeltas
                const σ = calculateStdDev(momentumDeltas.map(r => r.deviation)) || 1;
                const p = window.CONFIG.GEO_MODEL_CONFIG.lookbackWeightExponent;
                const scale = window.CONFIG.GEO_MODEL_CONFIG.scoreScale;

                const Lmax2 = Math.max(...momentumDeltas.map(r => r.lookback)); // same as Lmax but safe
                let weightedSum = 0;
                let weightTotal = 0;

                for (const res of momentumDeltas) {
                    const cat = sigCatStdDev(res.deviation, σ);
                    const direction = (cat.text === 'party' || cat.text === 'peachy') ? 1
                        : (cat.text === 'no bueno' || cat.text === 'watch') ? -1 : 0;
                    const zMag = Math.abs(res.deviation / σ);
                    const lengthFac = Math.pow(res.lookback / Lmax2, p);  // changed to p from -p Longest lookback should have more weight.
                    const weight = zMag * lengthFac;
                    weightedSum += direction * weight;
                    weightTotal += weight;
                }

                const consensusScore = weightTotal === 0 ? 0 : (weightedSum / weightTotal) * scale;

                const finalWordEl = document.getElementById('finalWord');
                if (consensusScore < window.CONFIG.UI_CONFIG.negativeThreshold) {
                    finalWordEl.textContent = 'Yep..';
                    finalWordEl.className = 'final-answer verdict-no';
                } else if (consensusScore > window.CONFIG.UI_CONFIG.positiveThreshold) {
                    finalWordEl.textContent = 'No. Tick‑tock, next block..';
                    finalWordEl.className = 'final-answer verdict-yep';
                } else {
                    finalWordEl.textContent = 'Yeah‑Nah';
                    finalWordEl.className = 'final-answer verdict-yeah-nah';
                }

            } catch (err) {
                const errEl = document.getElementById('errorStatus');
                errEl.style.display = '';
                errEl.textContent = 'Error loading: ' + err.message;
                console.error(err);
            }
        });
    </script>
</body>

</html>