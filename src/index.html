<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Bitcoin "Should I Care" Meter</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="css/styles.css">
    <script type="module">
        // Make config and analysis modules globally available for debugging if needed
        import { CONFIG } from './js/config.js';
        import * as analysis from './js/analysis.js';
        window.CONFIG = CONFIG;
        window.analysis = analysis;
    </script>
</head>

<body>
    <div class="container">
        <div class="header">
            <div class="weekly-movement" id="weeklyMovement"></div>
            <h1 class="main-title" id="mainTitle">Should I Care?</h1>
            <div class="block-info" id="blockInfo" style="display: none"></div>
        </div>

        <div class="content">
            <div class="section">
                <div class="section-title">Macro View - HOW IS BITCOIN DOING RELATIVE TO ITS ENTIRE HISTORY?</div>
                <table class="macro-table">
                    <tr>
                        <td>
                            <span class="label">Current Trend Angle</span>
                            <span class="value" id="currentAngle">—<span class="tooltip-icon">?</span>
                                <div class="tooltip">
                                    The angle of the line from Bitcoin's origin
                                    to its current price, normalized within
                                    a 1x1 box (Time vs Price/ATH). This defines
                                    the health of the macro trend.
                                </div>
                            </span>
                        </td>
                        <td>
                            <span class="label">ATH Benchmark</span>
                            <span class="value" id="benchmarkAngle">45°<span class="tooltip-icon">?</span>
                                <div class="tooltip">
                                    The theoretical ideal. This represents a
                                    perfect, straight line from origin to
                                    the All-Time High price on the
                                    normalized chart. It serves as a fixed
                                    reference point for the trend angle.
                                </div>
                            </span>
                        </td>
                        <td>
                            <span class="label">Current Price</span>
                            <span class="value" id="macroPrice">—<span class="tooltip-icon-subtle">?</span>
                                <div class="tooltip">
                                    Bitcoin's price. Updated live if possible, otherwise from the latest data point.
                                </div>
                            </span>
                        </td>
                        <td>
                            <span class="label">All Time High</span>
                            <span class="value" id="athPrice">—<span class="tooltip-icon-subtle">?</span>
                                <div class="tooltip">
                                    Bitcoin's highest recorded price. This
                                    defines the top of our geometric chart.
                                </div>
                            </span>
                        </td>
                    </tr>
                </table>
            </div>

            <div class="section">
                <div class="section-title">
                    Micro View - How is Bitcoin's momentum changing across time horizons?
                </div>
                <div class="micro-grid" id="microGrid">
                    <div class="calculating-overlay">
                        Calibrating & Analyzing...
                    </div>
                </div>
            </div>
        </div>

        <div class="final-word">
            <div class="final-question">
                So, should you Care about the price of Bitcoin?
            </div>
            <div class="final-answer" id="finalWord">...</div>
        </div>

        <div class="footer">
            <div class="footer-text">
                Each horizon shows momentum deviation relative to the overall macro trend.<br />
                This measures true acceleration, corrected for geometric distortion.
            </div>
            <a href="charts.html" class="footer-link">See the geometric charts →</a>
            <div class="error" id="errorStatus" style="display: none"></div>
        </div>
    </div>

    <script type="module">
        import {
            parseCsvLines,
            calculateQuadraticFit,
            generateLookbacks,
            calculateNormalizedSegmentAngle,
            calculateStdDev,
            sigCatStdDev
        } from './js/analysis.js';

        async function getLiveBitcoinPrice() {
            try {
                const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd');
                if (!response.ok) throw new Error('CoinGecko API request failed');
                const data = await response.json();
                return data.bitcoin.usd;
            } catch (error) {
                console.warn("Could not fetch live price, will use latest price from CSV.", error.message);
                return null;
            }
        }

        document.addEventListener("DOMContentLoaded", async () => {
            try {
                // ------------------------------------------------------------------
                // Data fetch & calibration
                // ------------------------------------------------------------------
                const bhResp = await fetch("https://blockstream.info/api/blocks/tip/height");
                const blockHeight = bhResp.ok ? parseInt(await bhResp.text()) : 0;

                const csvResp = await fetch(`${window.CONFIG.CSV_URL}?v=${Date.now()}`);
                if (!csvResp.ok) throw new Error(`Could not load CSV: ${csvResp.statusText}`);

                const lines = await csvResp.text().then(text => text.split("\n").slice(1).filter(l => l.trim()));
                if (lines.length < 2) throw new Error("No valid price data in CSV.");

                const lastCells = lines[0].split(",");
                const lastTimestamp = lastCells[0].includes("-") && lastCells[0].length === 10
                    ? new Date(lastCells[0] + "T00:00:00Z").getTime()
                    : new Date(Number(lastCells[0])).getTime();

                if (isNaN(lastTimestamp)) throw new Error(`Could not parse last date: ${lastCells[0]}`);

                const daysSinceGenesis = (Date.now() - window.CONFIG.GENESIS_DATE.getTime()) / 86_400_000;
                const trueBlocksPerDay = blockHeight > 0 ? blockHeight / daysSinceGenesis : 144;
                const lastDataBlockHeight = blockHeight - (Date.now() - lastTimestamp) * (trueBlocksPerDay / 86_400_000);
                const calibratedBlockTimeMs = (lastTimestamp - window.CONFIG.GENESIS_DATE.getTime()) / lastDataBlockHeight;

                if (calibratedBlockTimeMs <= 0) throw new Error("Invalid block time calculation.");

                const historical = parseCsvLines(lines, calibratedBlockTimeMs).sort((a, b) => a.block - b.block);
                document.querySelector(".calculating-overlay").style.display = "none";

                // ------------------------------------------------------------------
                // Macro metrics
                // ------------------------------------------------------------------
                const macroEnd = historical[historical.length - 1];
                const allTimeHigh = Math.max(...historical.map(d => d.price));
                const livePrice = await getLiveBitcoinPrice();
                const latestPrice = macroEnd.price;
                const displayPrice = livePrice || latestPrice;
                const latestBlock = macroEnd.block;
                const athBlock = historical.find(d => d.price === allTimeHigh)?.block || latestBlock;

                document.getElementById("blockInfo").textContent = `Live Block ${blockHeight.toLocaleString()} • Data to Block ${latestBlock.toLocaleString()}`;
                document.getElementById("blockInfo").style.display = "";

                const weekAgoBlock = latestBlock - 7 * trueBlocksPerDay;
                const weekAgoData = historical.slice().reverse().find(d => d.block <= weekAgoBlock);
                if (weekAgoData) {
                    const pct = ((displayPrice - weekAgoData.price) / weekAgoData.price) * 100;
                    const up = pct >= 0;
                    document.getElementById('weeklyMovement').innerHTML = `BTC is <span class="${up ? 'velocity-up' : 'velocity-down'}">${up ? 'up' : 'down'} ${Math.abs(pct).toFixed(1)}%</span> this week`;
                }

                const currentAngle = calculateNormalizedSegmentAngle(0, 0, latestBlock, displayPrice, athBlock, allTimeHigh);
                document.getElementById("currentAngle").innerHTML = `${currentAngle.toFixed(2)}°<span class="tooltip-icon">?</span><div class="tooltip">The angle of the line from Bitcoin's origin to its current price, normalized within a 1x1 box (Time vs Price/ATH). This defines the health of the macro trend.</div>`;
                document.getElementById("macroPrice").innerHTML = `$${displayPrice.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}<span class="tooltip-icon-subtle">?</span><div class="tooltip">Bitcoin's price. Updated live if possible, otherwise from the latest data point.</div>`;
                document.getElementById("athPrice").innerHTML = `$${allTimeHigh.toLocaleString()}<span class="tooltip-icon-subtle">?</span><div class="tooltip">Bitcoin's highest recorded price. This defines the top of our geometric chart.</div>`;

                // ------------------------------------------------------------------
                // Look-back generation and momentum analysis
                // ------------------------------------------------------------------
                const normData = historical.map(d => ({ x: d.block / athBlock, y: d.price / allTimeHigh }));
                const { a: curvature } = calculateQuadraticFit(normData);
                const angularRatio = currentAngle / 45.0;

                const lookbacks = generateLookbacks(latestBlock, curvature, angularRatio, window.CONFIG.GEO_MODEL_CONFIG);

                const microGrid = document.getElementById("microGrid");
                microGrid.innerHTML = "";

                // 1. Calculate the angle for each generated lookback period.
                let angleResults = [];
                for (const lookback of lookbacks) {
                    const startBlock = latestBlock - lookback;
                    if (startBlock <= 0) continue;
                    const startRow = historical.slice().reverse().find(d => d.block <= startBlock) || historical[0];
                    const microAngle = calculateNormalizedSegmentAngle(startRow.block, startRow.price, latestBlock, displayPrice, athBlock, allTimeHigh);
                    angleResults.push({ lookback, microAngle });
                }

                if (angleResults.length < 2) {
                    microGrid.innerHTML = "<div class='calculating-overlay'>Not enough data for momentum analysis.</div>";
                    return;
                }

                // ====================================================================
                // ========= CORRECTED AND SIMPLIFIED DEVIATION LOGIC =========
                // ====================================================================
                const momentumDeltas = [];

                for (const result of angleResults) {
                    // The deviation is the difference between this horizon's angle and the
                    // overall macro trend angle (`currentAngle`). This is the most direct 
                    // and stable measure of momentum change, avoiding cascading errors.
                    const deviation = result.microAngle - currentAngle;
                    momentumDeltas.push({
                        lookback: result.lookback,
                        deviation: deviation,
                    });
                }
                // ====================================================================

                // ------------------------------------------------------------------
                // Weighted consensus score
                // ------------------------------------------------------------------
                const σ = calculateStdDev(momentumDeltas.map(r => r.deviation)) || 1;
                const Lmax = Math.max(...momentumDeltas.map(r => r.lookback));
                const p = window.CONFIG.GEO_MODEL_CONFIG.lookbackWeightExponent;
                const scale = window.CONFIG.GEO_MODEL_CONFIG.scoreScale;

                let weightedSum = 0;
                let weightTotal = 0;

                for (const res of momentumDeltas) {
                    const cat = sigCatStdDev(res.deviation, σ);
                    const direction = cat.text === "party" || cat.text === "peachy" ? 1 : cat.text === "no bueno" || cat.text === "watch" ? -1 : 0;
                    const zMag = Math.abs(res.deviation / σ);
                    const lengthFac = Math.pow(Lmax / res.lookback, p);
                    const weight = zMag * lengthFac;
                    weightedSum += direction * weight;
                    weightTotal += weight;

                    const card = document.createElement("div");
                    card.className = "micro-card";
                    card.innerHTML =
                        `<div class="horizon">${res.lookback.toLocaleString()} Block Lookback</div>` +
                        `<div class="signal ${cat.cls}">${cat.text}</div>` +
                        `<div class="detail">${res.deviation >= 0 ? "↗" : "↘"} ${res.deviation.toFixed(1)}°</div>`;
                    microGrid.appendChild(card);
                }

                const consensusScore = weightTotal === 0 ? 0 : (weightedSum / weightTotal) * scale;

                // ------------------------------------------------------------------
                // Final verdict
                // ------------------------------------------------------------------
                const finalWordEl = document.getElementById("finalWord");
                if (consensusScore < window.CONFIG.UI_CONFIG.negativeThreshold) {
                    finalWordEl.textContent = "Yep..";
                    finalWordEl.className = "final-answer verdict-no";
                } else if (consensusScore > window.CONFIG.UI_CONFIG.positiveThreshold) {
                    finalWordEl.textContent = "No. Tick-tock, next block..";
                    finalWordEl.className = "final-answer verdict-yep";
                } else {
                    finalWordEl.textContent = "Yeah-Nah";
                    finalWordEl.className = "final-answer verdict-yeah-nah";
                }

            } catch (err) {
                document.getElementById("errorStatus").style.display = "";
                document.getElementById("errorStatus").textContent = "Error loading: " + err.message;
                console.error(err);
            }
        });
    </script>
</body>

</html>